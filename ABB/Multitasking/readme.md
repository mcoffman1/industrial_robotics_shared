![LOGO](images/LOGO.png)

# ⚠️ Warning  

This is a **general guide to ABB multitasking**.  
The code examples below were **generated by AI and have not been tested on a real robot**.  
Code will be updated and pictures will be added once testing is complete.  

---

# ABB Multitasking Example – Pushbutton-Driven Routines

This guide shows how to configure an ABB robot to run background logic using **Multitasking**.  
In this example, four pushbuttons (Red, Green, Blue, Yellow) are wired to digital inputs.  
Each button corresponds to a robot routine.  

- When a button is pressed, the background task:  
  - Turns on a light (digital output) to indicate the request.  
  - Queues the request in the order buttons are pressed.  
- The robot continues its current motion routine.  
- When the motion task finishes, it checks the queue:  
  - Runs the requested routine.  
  - Turns **off the corresponding light**.  

This setup allows multiple requests to be queued and executed in sequence.  

---

## Signals

| Pushbutton | Digital Input | Indicator Light (DO) |
|------------|---------------|-----------------------|
| Red        | DI1           | DO1                  |
| Green      | DI2           | DO2                  |
| Blue       | DI3           | DO3                  |
| Yellow     | DI4           | DO4                  |

---

## Main Motion Task (`MainTask.mod`)

The **main task** executes robot motion routines.  
It continuously checks for queued requests and runs them in order.  

```Rapid
MODULE MainTask
    VAR string requestQueue{20};   ! FIFO queue for up to 20 requests
    VAR num head := 1;
    VAR num tail := 1;

    PROC main()
        WHILE TRUE DO
            ! Perform normal production routine here
            ! (Insert your existing logic)
            TPWrite "Main routine running...";

            ! Check if a request is waiting
            IF head <> tail THEN
                VAR string req;
                req := requestQueue[head];
                head := head + 1;
                IF head > Dim(requestQueue,1) THEN
                    head := 1;
                ENDIF;

                ! Execute the requested routine
                TPWrite "Executing request: "\req;

                IF req = "RED" THEN
                    RedRoutine;
                    SetDO DO1, 0;   ! Turn off RED light
                ELSEIF req = "GREEN" THEN
                    GreenRoutine;
                    SetDO DO2, 0;   ! Turn off GREEN light
                ELSEIF req = "BLUE" THEN
                    BlueRoutine;
                    SetDO DO3, 0;   ! Turn off BLUE light
                ELSEIF req = "YELLOW" THEN
                    YellowRoutine;
                    SetDO DO4, 0;   ! Turn off YELLOW light
                ENDIF;
            ENDIF;

            WaitTime 0.1;
        ENDWHILE
    ENDPROC
ENDMODULE
```

---

## Background Task (`BG_Task.mod`)

The **background task** monitors the pushbuttons.  
When a button is pressed, it:  
1. Queues a request.  
2. Turns on the corresponding light.  

```Rapid
MODULE BG_Task
    TASK PERS string requestQueue{20};   ! Shared queue
    TASK PERS num head := 1;
    TASK PERS num tail := 1;

    PROC main()
        WHILE TRUE DO
            ! Check RED button
            IF DI1 = 1 THEN
                Enqueue("RED");
                SetDO DO1, 1;
                WaitUntil DI1=0;   ! Wait for release
            ENDIF;

            ! Check GREEN button
            IF DI2 = 1 THEN
                Enqueue("GREEN");
                SetDO DO2, 1;
                WaitUntil DI2=0;
            ENDIF;

            ! Check BLUE button
            IF DI3 = 1 THEN
                Enqueue("BLUE");
                SetDO DO3, 1;
                WaitUntil DI3=0;
            ENDIF;

            ! Check YELLOW button
            IF DI4 = 1 THEN
                Enqueue("YELLOW");
                SetDO DO4, 1;
                WaitUntil DI4=0;
            ENDIF;

            WaitTime 0.05;
        ENDWHILE
    ENDPROC

    PROC Enqueue(req STRING)
        requestQueue[tail] := req;
        tail := tail + 1;
        IF tail > Dim(requestQueue,1) THEN
            tail := 1;
        ENDIF;
    ENDPROC
ENDMODULE
```

---

## Setup Steps

1. **Enable Multitasking**  
   - FlexPendant → Menu → Controller → System Parameters → Controller → Tasks → Multitasking = *On*.  

2. **Create Tasks**  
   - Task 1: `MainTask` (motion-enabled).  
   - Task 2: `BG_Task` (non-motion, background).  

3. **Configure Auto Start**  
   - Set `BG_Task` to Auto Start so it always runs when the controller starts.  

4. **Assign I/O**  
   - Map DI1–DI4 to pushbuttons.  
   - Map DO1–DO4 to indicator lights.  

---

## Notes

- Motion routines (`RedRoutine`, `GreenRoutine`, etc.) must already be defined in your main program library.  
- The queue logic is **FIFO** (first in, first out). Requests are executed in the order buttons are pressed.  
- Add bounds checking if you expect very long queues.  
- Background task cannot move the robot (non-motion), but it can set flags, monitor I/O, and handle logic.  

---

With this setup, the goal is that indicator lights turn **on when a button is pressed**, and **off after the associated routine completes**.  
